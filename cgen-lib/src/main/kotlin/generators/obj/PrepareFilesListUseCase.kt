package generators.obj

import ce.settings.Project
import generators.obj.input.*
import generators.obj.out.CommentsBlock
import generators.obj.out.FileData
import generators.obj.out.OutputTree
import java.io.File
import java.nio.file.Paths
import javax.inject.Inject

interface PrepareFilesListUseCase {
    operator fun invoke(root: Node, projectOut: OutputTree): Map<String, List<FileData>>
}

class PrepareFilesListUseCaseImpl @Inject constructor(
    private val project: Project,
    private val fileGenerator: FileGenerator,
) : PrepareFilesListUseCase {
    override fun invoke(root: Node, projectOut: OutputTree): Map<String, List<FileData>> {
        val files = mutableMapOf<String, List<FileData>>()
        prepareFilesByTree(projectOut, root, files)
        return files
    }

    private fun prepareFilesByTree(projectOut: OutputTree, root: Node, files: MutableMap<String, List<FileData>>) {
        root.subs.forEach {
            if (it is Block) {
                val outputFile = fileGenerator.getBlockFilePath(it)
                if (!files.contains(outputFile)) {
                    val listOfFiles = fileGenerator.createFile(projectOut, outputFile, it)
                    listOfFiles.forEach { fileData ->
                        projectOut.addSub(fileData)
                        if (project.addAutogeneratedCommentNotification) {
                            val fileObject = File(outputFile).canonicalFile
                            val pathAbsolute = Paths.get(it.sourceFile)
                            val pathBase = Paths.get(fileObject.absolutePath)
                            val pathRelative = pathBase.relativize(pathAbsolute)
                            fileData.findOrCreateSub(CommentsBlock::class.java).apply {
                                addCommentLine("Warning! This file is autogenerated.")
                                addCommentLine("Source file $pathRelative")
                            }
                            fileData.isDirty = false
                        }
                    }
                    files[outputFile] = listOfFiles
                }
            } else if (it is Node) {
                prepareFilesByTree(projectOut, it, files)
            }
        }
    }

}