package generators.obj

import ce.defs.Target
import ce.settings.Project
import generators.obj.input.Block
import generators.obj.input.Node
import generators.obj.out.CommentsBlock
import generators.obj.out.FileData
import generators.obj.out.ProjectOutput
import java.io.File
import java.nio.file.Paths

open class MetaGenerator(
    private val target: Target,
    private val fileGenerator: FileGenerator,
    private val generatorsMap: Map<Class<out Block>, Generator<out Block>>,
    private val writter: Writter,
    private val project: Project
) {

    private fun prepareFilesByTree(projectOut: ProjectOutput, root: Node, files: MutableMap<String, List<FileData>>) {
        root.subs.forEach {
            if (it is Block) {
                val outputFile = fileGenerator.getBlockFilePath(it)
                if (!files.contains(outputFile)) {
                    val listOfFiles = fileGenerator.createFile(projectOut, outputFile, it)
                    listOfFiles.forEach { fileData ->
                        projectOut.addSub(fileData)
                        if (project.addAutogeneratedCommentNotification) {
                            val fileObject = File(outputFile).canonicalFile
                            val pathAbsolute = Paths.get(it.sourceFile)
                            val pathBase = Paths.get(fileObject.absolutePath)
                            val pathRelative = pathBase.relativize(pathAbsolute)
                            fileData.findOrCreateSub(CommentsBlock::class.java).apply {
                                addCommentLine("${fileGenerator.singleComment()} Warning! This file is autogenerated.")
                                addCommentLine("${fileGenerator.singleComment()} Source file $pathRelative")
                            }
                            fileData.resetDirtyFlag()
                        }
                    }
                    files[outputFile] = listOfFiles
                }
            } else if (it is Node) {
                prepareFilesByTree(projectOut, it, files)
            }
        }
    }

    private fun translateTree(root: Node, files: MutableMap<String, List<FileData>>) {
        root.subs.forEach {
            if (it is Block) {
                val outputFile = fileGenerator.getBlockFilePath(it)
                val filesData = files[outputFile]!!

                val namespacePath = it.getParentPath()
                println("Translating ${it.name}")
                if (generatorsMap.contains(it::class.java)) {
                    val generator = generatorsMap.get(it::class.java)!! as Generator<Block>
                    generator.processBlock(filesData, it)
                } else {
//                    val classData = when (it) {
//                        is ConstantsEnum -> enum.processBlock(filesData, it)
//                        is ConstantsBlock -> constantsBlock.processBlock(filesData, it)
//                        is DataClass -> dataClass.processBlock(filesData, it)
//                        else -> null
//                    }
//                    classData?.let {
//                        // TODO check duplicate block in namespace
//                if (namespace.outputBlocks.contains(block.name)) {
//                    throw java.lang.IllegalStateException(
//                        "Duplicate block error! ${namespace.name} already contains block with name ${block.name}"
//                    );
//                }
//                    }
                }

            } else if (it is Node) {
                translateTree(it, files)
            } else {
                error("Unknown leaf ${it}")
            }
        }
    }

    fun translateToOutTree(intree: Node): ProjectOutput {
        val result = ProjectOutput(target)
        val files = mutableMapOf<String, List<FileData>>()
        prepareFilesByTree(result, intree, files)
        translateTree(intree, files)
        return result
    }


    fun write(projectOutput: ProjectOutput) {
        writter.write(projectOutput)
    }
}