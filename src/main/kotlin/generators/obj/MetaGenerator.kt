package generators.obj

import ce.defs.Target
import ce.settings.Project
import generators.obj.input.*
import generators.obj.out.ClassData
import generators.obj.out.FileData
import generators.obj.out.ProjectOutput
import java.io.File
import java.nio.file.Paths


open class MetaGenerator<T : ClassData>(
    val target: Target = Target.Other,
    val enum: Generator<ConstantsEnum, T>,
    val constantsBlock: Generator<ConstantsBlock, T>,
    val dataClass: Generator<DataClass, T>,
    val fileGenerator: FileGenerator,
    private val writter: Writter,
    private val project: Project
) {

    private fun prepareFilesByTree(projectOut: ProjectOutput, root: Node, files: MutableMap<String, FileData>) {
        root.subs.forEach {
            if (it is Block) {
                val outputFile = fileGenerator.getBlockFilePath(it)
                if (!files.contains(outputFile)) {
                    val data = fileGenerator.createFile(projectOut, outputFile, it)
                    projectOut.subs.add(data)
                    if (project.addAutogeneratedCommentNotification) {
                        val fileObject = File(outputFile).canonicalFile
                        val pathAbsolute = Paths.get(it.sourceFile)
                        val pathBase = Paths.get(fileObject.absolutePath)
                        val pathRelative = pathBase.relativize(pathAbsolute)
                        fileGenerator.appendInitialComment(data, "Warning! This file is autogenerated.")
                        fileGenerator.appendInitialComment(data, "Source file $pathRelative")
                    }
                    files[outputFile] = data
                }
            } else if (it is Node) {
                prepareFilesByTree(projectOut, it, files)
            }
        }
    }

    private fun translateTree(root: Node, files: MutableMap<String, FileData>) {
        root.subs.forEach {
            if (it is Block) {
                val outputFile = fileGenerator.getBlockFilePath(it)
                val fileData = files[outputFile]!!

                val namespacePath = it.getParentPath()
                val blockNs = fileData.getNamespace(namespacePath)

                val classData = when (it) {
                    is ConstantsEnum -> enum.processBlock(fileData, blockNs, it)
                    is ConstantsBlock -> constantsBlock.processBlock(fileData, blockNs, it)
                    is DataClass -> dataClass.processBlock(fileData, blockNs, it)
                    else -> null
                }
                classData?.let {
                    // TODO check duplicate block in namespace
//                if (namespace.outputBlocks.contains(block.name)) {
//                    throw java.lang.IllegalStateException(
//                        "Duplicate block error! ${namespace.name} already contains block with name ${block.name}"
//                    );
//                }
                    blockNs.subs.add(classData)
                }

            } else if (it is Node) {
                translateTree(it, files)
            } else {
                error("Unknown leaf ${it}")
            }
        }
    }


    open fun processProject(root: Node, namespaceMap: NamespaceMap): ProjectOutput {
        val result = ProjectOutput(namespaceMap)
        val files = mutableMapOf<String, FileData>()
        prepareFilesByTree(result, root, files)
        translateTree(root, files)
        return result
    }


    fun write(root: Node, namespaceMap: NamespaceMap) {
        val projectOutput = processProject(root, namespaceMap)
        writter.write(projectOutput)
    }
}